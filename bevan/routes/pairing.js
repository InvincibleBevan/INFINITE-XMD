const express = require('express');
const fs = require('fs');
const path = require('path');
const pino = require("pino");
const {
    default: makeWASocket,
    useMultiFileAuthState,
    delay,
    makeCacheableSignalKeyStore,
    Browsers
} = require("@whiskeysockets/baileys");

const router = express.Router();

// Utility functions
function generateId() {
    return Math.random().toString(36).substring(2, 15);
}

function removeFile(filePath) {
    if (!fs.existsSync(filePath)) return false;
    fs.rmSync(filePath, { recursive: true, force: true });
    return true;
}

// Format phone number correctly for WhatsApp
function formatPhoneNumber(number) {
    // Remove all non-digits
    let cleanNumber = number.replace(/\D/g, '');
    
    // If number starts with 0, replace with country code (assuming Kenya +254)
    if (cleanNumber.startsWith('0')) {
        cleanNumber = '254' + cleanNumber.substring(1);
    }
    
    // If number doesn't have country code, add +254 (Kenya)
    if (cleanNumber.length === 9) {
        cleanNumber = '254' + cleanNumber;
    }
    
    return cleanNumber;
}

const activeSessions = new Map();

// INSTANT QR Code Generation
router.get('/qr', async (req, res) => {
    const sessionId = generateId();
    const tempDir = path.join(__dirname, 'temp', sessionId);
    fs.mkdirSync(tempDir, { recursive: true });

    console.log('ðŸš€ Starting INSTANT QR generation...');

    try {
        const { state, saveCreds } = await useMultiFileAuthState(tempDir);

        const sock = makeWASocket({
            auth: {
                creds: state.creds,
                keys: makeCacheableSignalKeyStore(state.keys, pino({ level: "fatal" })),
            },
            printQRInTerminal: true,
            logger: pino({ level: "info" }),
            browser: Browsers.macOS("Safari"),
            connectTimeoutMs: 30000,
            keepAliveIntervalMs: 10000,
            // CRITICAL: Add these options for better connection
            markOnlineOnConnect: true,
            syncFullHistory: false,
            transactionOpts: {
                maxCommitRetries: 3,
                delayBetweenTriesMs: 1000
            }
        });

        // Store the socket IMMEDIATELY
        activeSessions.set(sessionId, { sock, tempDir, createdAt: Date.now() });

        let qrSent = false;

        // Send QR code INSTANTLY
        sock.ev.on("connection.update", async (update) => {
            const { connection, lastDisconnect, qr } = update;

            if (qr && !qrSent) {
                console.log('ðŸ“± QR code generated INSTANTLY');
                qrSent = true;
                
                res.json({ 
                    success: true, 
                    qr: qr,
                    sessionId: sessionId 
                });
            }

            if (connection === "open") {
                console.log('âœ… WhatsApp CONNECTED successfully');
                
                try {
                    const credsPath = path.join(tempDir, 'creds.json');
                    if (fs.existsSync(credsPath)) {
                        const sessionData = fs.readFileSync(credsPath, 'utf8');
                        const base64Session = Buffer.from(sessionData).toString('base64');
                        const infinitySession = "INFINITY_" + base64Session;

                        const message = `ðŸ” *YOUR WHATSAPP SESSION ID* - INFINITE-XMD

*Session ID:*
\`\`\`
${infinitySession}
\`\`\`

*Generated:* ${new Date().toLocaleString()}

ðŸ’» Generated by Bevan Society`;

                        await sock.sendMessage(sock.user.id, { text: message });
                        console.log('âœ… Session sent to user');
                    }
                } catch (error) {
                    console.error('Error sending session:', error);
                }

                // Cleanup after success
                setTimeout(() => {
                    sock.ws.close();
                    removeFile(tempDir);
                    activeSessions.delete(sessionId);
                }, 5000);
            }
            
            else if (connection === "close") {
                console.log('âŒ Connection closed');
                removeFile(tempDir);
                activeSessions.delete(sessionId);
            }
        });

        // Timeout after 30 seconds
        setTimeout(() => {
            if (activeSessions.has(sessionId) && !qrSent) {
                sock.ws.close();
                removeFile(tempDir);
                activeSessions.delete(sessionId);
                if (!res.headersSent) {
                    res.status(408).json({ error: 'QR generation timeout' });
                }
            }
        }, 30000);

    } catch (error) {
        console.error('âŒ QR generation error:', error);
        removeFile(tempDir);
        if (!res.headersSent) {
            res.status(500).json({ 
                error: 'Failed to generate QR code',
                details: error.message 
            });
        }
    }
});

// INSTANT Pairing Code Generation - FIXED
router.get('/code', async (req, res) => {
    const { number } = req.query;
    
    if (!number) {
        return res.status(400).json({ error: 'Phone number required' });
    }

    const sessionId = generateId();
    const tempDir = path.join(__dirname, 'temp', sessionId);
    fs.mkdirSync(tempDir, { recursive: true });

    console.log('ðŸš€ Starting INSTANT pairing for:', number);

    try {
        const { state, saveCreds } = await useMultiFileAuthState(tempDir);

        const sock = makeWASocket({
            auth: {
                creds: state.creds,
                keys: makeCacheableSignalKeyStore(state.keys, pino({ level: "fatal" })),
            },
            printQRInTerminal: true,
            logger: pino({ level: "info" }),
            browser: Browsers.macOS("Safari"),
            connectTimeoutMs: 30000,
            // CRITICAL: Force immediate connection
            markOnlineOnConnect: true,
            syncFullHistory: false,
            fireInitQueries: true,
            generateHighQualityLinkPreview: false
        });

        // CRITICAL: Store socket immediately
        activeSessions.set(sessionId, { sock, tempDir, createdAt: Date.now() });

        // Generate pairing code INSTANTLY
        if (!sock.authState.creds.registered) {
            try {
                const formattedNumber = formatPhoneNumber(number);
                console.log('ðŸ“ž Requesting pairing code for:', formattedNumber);
                
                // REQUEST PAIRING CODE IMMEDIATELY
                const pairingCode = await sock.requestPairingCode(formattedNumber);
                console.log('âœ… Pairing code generated:', pairingCode);

                res.json({ 
                    success: true, 
                    code: pairingCode,
                    sessionId: sessionId,
                    message: 'Use this code in WhatsApp within 2 minutes'
                });

                // Listen for connection events
                sock.ev.on("connection.update", async (update) => {
                    const { connection } = update;

                    if (connection === "open") {
                        console.log('âœ… Pairing SUCCESSFUL - User connected');
                        
                        try {
                            const credsPath = path.join(tempDir, 'creds.json');
                            if (fs.existsSync(credsPath)) {
                                const sessionData = fs.readFileSync(credsPath, 'utf8');
                                const base64Session = Buffer.from(sessionData).toString('base64');
                                const infinitySession = "INFINITY_" + base64Session;

                                const message = `ðŸ” *YOUR WHATSAPP SESSION ID* - INFINITE-XMD

*Session ID:*
\`\`\`
${infinitySession}
\`\`\`

*Generated:* ${new Date().toLocaleString()}

ðŸ’» Generated by Bevan Society`;

                                await sock.sendMessage(sock.user.id, { text: message });
                                console.log('âœ… Session sent to user');
                            }
                        } catch (error) {
                            console.error('Error sending session:', error);
                        }

                        // Cleanup
                        setTimeout(() => {
                            sock.ws.close();
                            removeFile(tempDir);
                            activeSessions.delete(sessionId);
                        }, 5000);
                    }
                });

            } catch (error) {
                console.error('âŒ Pairing code error:', error);
                
                // Cleanup on error
                if (sock.ws) {
                    await sock.ws.close();
                }
                removeFile(tempDir);
                activeSessions.delete(sessionId);
                
                res.status(500).json({ 
                    success: false,
                    error: 'Failed to generate pairing code',
                    details: error.message,
                    tip: 'Make sure the number is correct and includes country code (e.g., 254712345678)'
                });
            }
        }

    } catch (error) {
        console.error('âŒ Pairing setup error:', error);
        removeFile(tempDir);
        res.status(500).json({ 
            success: false,
            error: 'Failed to setup pairing',
            details: error.message
        });
    }
});

// Status endpoint to check connection
router.get('/status', (req, res) => {
    res.json({
        status: 'ðŸŸ¢ Online and ready',
        activeSessions: activeSessions.size,
        timestamp: new Date().toISOString(),
        version: '2.0.0',
        developer: 'Bevan Society'
    });
});

// Session validation endpoint
router.get('/validate/:sessionId', (req, res) => {
    const { sessionId } = req.params;
    const session = activeSessions.get(sessionId);
    
    if (session) {
        res.json({
            valid: true,
            age: Date.now() - session.createdAt,
            active: true
        });
    } else {
        res.json({
            valid: false,
            active: false
        });
    }
});

// Cleanup expired sessions every 5 minutes
setInterval(() => {
    const now = Date.now();
    for (const [sessionId, session] of activeSessions.entries()) {
        if (now - session.createdAt > 300000) { // 5 minutes
            if (session.sock) {
                try {
                    session.sock.ws.close();
                } catch (error) {
                    console.error('Error closing socket:', error);
                }
            }
            removeFile(session.tempDir);
            activeSessions.delete(sessionId);
            console.log('ðŸ§¹ Cleaned up expired session:', sessionId);
        }
    }
}, 300000); // 5 minutes

// Emergency cleanup endpoint
router.post('/cleanup', (req, res) => {
    let cleaned = 0;
    for (const [sessionId, session] of activeSessions.entries()) {
        if (session.sock) {
            try {
                session.sock.ws.close();
            } catch (error) {
                console.error('Error closing socket:', error);
            }
        }
        removeFile(session.tempDir);
        activeSessions.delete(sessionId);
        cleaned++;
    }
    
    res.json({
        success: true,
        message: `Cleaned up ${cleaned} sessions`,
        cleaned: cleaned
    });
});

module.exports = router;
