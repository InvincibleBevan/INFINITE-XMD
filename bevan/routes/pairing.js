const express = require('express');
const fs = require('fs');
const path = require('path');
const pino = require("pino");
const {
    default: makeWASocket,
    useMultiFileAuthState,
    delay,
    makeCacheableSignalKeyStore,
    Browsers
} = require("@whiskeysockets/baileys");

const router = express.Router();

// Utility: Generate random ID
function generateId() {
    return Math.random().toString(36).substring(2, 15);
}

// Utility: Remove file/folder
function removeFile(filePath) {
    if (!fs.existsSync(filePath)) return false;
    fs.rmSync(filePath, { recursive: true, force: true });
    return true;
}

// Store active pairing sessions
const activeSessions = new Map();

// GET endpoint for pairing codes
router.get('/code', async (req, res) => {
    const { number } = req.query;
    
    if (!number) {
        return res.status(400).json({ error: 'Phone number required' });
    }

    const sessionId = generateId();
    const tempDir = path.join(__dirname, 'temp', sessionId);

    try {
        const { state, saveCreds } = await useMultiFileAuthState(tempDir);

        const sock = makeWASocket({
            auth: {
                creds: state.creds,
                keys: makeCacheableSignalKeyStore(state.keys, pino({ level: "fatal" })),
            },
            printQRInTerminal: false,
            logger: pino({ level: "fatal" }),
            browser: Browsers.macOS("Safari")
        });

        sock.ev.on('creds.update', saveCreds);

        sock.ev.on("connection.update", async (update) => {
            const { connection, lastDisconnect } = update;

            if (connection === "open") {
                await delay(2000);

                // Read session data and convert to Base64
                const credsPath = path.join(tempDir, 'creds.json');
                if (fs.existsSync(credsPath)) {
                    try {
                        const sessionData = fs.readFileSync(credsPath, 'utf8');
                        const base64Session = Buffer.from(sessionData).toString('base64');
                        const infinitySession = "INFINITY_" + base64Session;

                        // Send session to user's WhatsApp
                        const message = `
🔐 *YOUR WHATSAPP SESSION ID* - INFINITE-XMD

*Session ID:*
\`\`\`
${infinitySession}
\`\`\`

*Generated:* ${new Date().toLocaleString()}
*Keep this safe!* Anyone with this session can access your WhatsApp.

💻 Generated by Bevan Society Session Server
                        `;

                        await sock.sendMessage(sock.user.id, { text: message });
                        
                        // Cleanup
                        await delay(500);
                        await sock.ws.close();
                        removeFile(tempDir);
                        activeSessions.delete(sessionId);

                    } catch (error) {
                        console.error('Session processing error:', error);
                    }
                }
            }
            
            else if (connection === "close" && lastDisconnect?.error) {
                // Cleanup on error
                removeFile(tempDir);
                activeSessions.delete(sessionId);
            }
        });

        // Request pairing code
        if (!sock.authState.creds.registered) {
            await delay(1000);
            const cleanNumber = number.replace(/[^0-9]/g, '');
            const pairingCode = await sock.requestPairingCode(cleanNumber);
            
            // Store session for later cleanup
            activeSessions.set(sessionId, { sock, tempDir, createdAt: Date.now() });
            
            res.json({ 
                success: true, 
                code: pairingCode,
                sessionId: sessionId 
            });
        }

    } catch (error) {
        console.error('Pairing error:', error);
        removeFile(tempDir);
        res.status(500).json({ error: 'Failed to generate pairing code' });
    }
});

// GET endpoint for QR code
router.get('/qr', async (req, res) => {
    const { number } = req.query;
    
    if (!number) {
        return res.status(400).json({ error: 'Phone number required' });
    }

    const sessionId = generateId();
    const tempDir = path.join(__dirname, 'temp', sessionId);

    try {
        const { state, saveCreds } = await useMultiFileAuthState(tempDir);

        const sock = makeWASocket({
            auth: {
                creds: state.creds,
                keys: makeCacheableSignalKeyStore(state.keys, pino({ level: "fatal" })),
            },
            printQRInTerminal: false,
            logger: pino({ level: "fatal" }),
            browser: Browsers.macOS("Safari")
        });

        sock.ev.on('creds.update', saveCreds);

        sock.ev.on("connection.update", async (update) => {
            const { connection, lastDisconnect, qr } = update;

            if (qr) {
                // Send QR code to client
                res.json({ 
                    success: true, 
                    qr: qr,
                    sessionId: sessionId 
                });
            }

            if (connection === "open") {
                await delay(2000);

                // Read session data and convert to Base64
                const credsPath = path.join(tempDir, 'creds.json');
                if (fs.existsSync(credsPath)) {
                    try {
                        const sessionData = fs.readFileSync(credsPath, 'utf8');
                        const base64Session = Buffer.from(sessionData).toString('base64');
                        const infinitySession = "INFINITY_" + base64Session;

                        // Send session to user's WhatsApp
                        const message = `
🔐 *YOUR WHATSAPP SESSION ID* - INFINITE-XMD

*Session ID:*
\`\`\`
${infinitySession}
\`\`\`

*Generated:* ${new Date().toLocaleString()}
*Keep this safe!* Anyone with this session can access your WhatsApp.

💻 Generated by Bevan Society Session Server
                        `;

                        await sock.sendMessage(sock.user.id, { text: message });
                        
                        // Cleanup
                        await delay(500);
                        await sock.ws.close();
                        removeFile(tempDir);
                        activeSessions.delete(sessionId);

                    } catch (error) {
                        console.error('Session processing error:', error);
                    }
                }
            }
            
            else if (connection === "close" && lastDisconnect?.error) {
                // Cleanup on error
                removeFile(tempDir);
                activeSessions.delete(sessionId);
            }
        });

        // Store session for cleanup
        activeSessions.set(sessionId, { sock, tempDir, createdAt: Date.now() });

    } catch (error) {
        console.error('QR generation error:', error);
        removeFile(tempDir);
        res.status(500).json({ error: 'Failed to generate QR code' });
    }
});

// Cleanup expired sessions (5 minutes)
setInterval(() => {
    const now = Date.now();
    for (const [sessionId, session] of activeSessions.entries()) {
        if (now - session.createdAt > 300000) {
            if (session.sock) session.sock.ws.close();
            removeFile(session.tempDir);
            activeSessions.delete(sessionId);
        }
    }
}, 60000);

module.exports = router;
